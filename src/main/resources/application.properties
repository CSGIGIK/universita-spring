
spring.application.name=UniversityTestProject 

# ========== MYSQL CONFIG ==========

#spring.datasource.url=jdbc:mysql://localhost:3306/NomeSchema?https=si/no&serverTimezone=UTC&allowPublicKeyRetrieval=true
#MySQL 8.0+ NON ha fuso orario di default, quindi è necessario specificarlo esplicitamente serverTimezone=UTC
#&AllowPublicKeyRetrieval=true è necessario se si utilizza una password per l'utente root, altrimenti si riceverà un errore di autenticazione

spring.datasource.url=jdbc:mysql://localhost:3306/UniversitaOfficial?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true 
spring.datasource.username=root
spring.datasource.password=Root

#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver e il cavo che collega il progetto al database, 
#senza di esso non si riesce a connettere al database e si riceve un errore di connessione. 
#è necessario specificare la classe del driver JDBC per MySQL, che è com.mysql.cj.jdbc.Driver che abbiamo importato;
#dependency nel nostro progetto al posto di maven stiamo usando gradle build.gradle.

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ========== JPA/HIBERNATE ==========
# e il TRADUTTORE che trasforma classi Java in tabelle MySQL,
#senza di esso dovremmo scrivere SQL manuale (JDBC puro = 80% boilerplate)

#JPA = standard (regole) per la gestione dei dati in Java,sblocca annotazioni come @Entity, @Table, @Id, @Column, @ecc 
#ci permettono di definire le nostre entità e le relazioni tra di esse 

#Hibernate = implementazione (realizzazione concreta) di JPA traduce annotazioni JPA in SQL specifico per MySQL, 
#gestisce la connessione al database, esegue le query, gestisce le transazioni, ecc.

#Dependency gia nel progetto spring-boot-starter-data-jpa che include sia JPA che Hibernate, 
#quindi non è necessario aggiungere ulteriori dipendenze per utilizzare JPA/Hibernate nel nostro progetto.



spring.jpa.hibernate.ddl-auto=update 
#crea o aggiorna le tabelle in base alle entità, senza perdere dati esistenti
#FLUSSO: @SpringBootApplication legge etichette → vede @Entity → chiama JPA/Hibernate → 
#JPA fornisce metodi → Hibernate traduce @Entity → crea/aggiorna tabella reale automaticamente
#per la produzione cambieremo update con none/validate per evitare modifiche automatiche al database.

spring.jpa.show-sql=true
#DEBUG: mostra le istruzioni SQL lanciate da Hibernate nei log(dove le mostra? nella console di output del progetto, non in MySQL Workbench)


spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
#cosa fa? dice a Hibernate che lingua parla il database MySQL, così traduce correttamente le query SQL in sintassi MySQL specifica,
#se usassimo un database diverso dovremmo cambiare questa proprietà per il dialetto corrispondente.
#org.hibernate.dialect.MySQL8Dialect NON esiste in Hibernate 7.2.4.Final, 
#usiamo MySQLDialect che è universale e compatibile con MySQL 5.7/8.0+ automaticamente.
#anche se Spring Boot lo rileva automaticamente in base al driver, 
#è buona pratica specificarlo esplicitamente per evitare problemi di compatibilità o errori di rilevamento automatico.